# -*- coding: utf-8 -*-
"""Copia de Avance Tarea 1 Progra Avanzada.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rSR1osBbmz11NzbIucrE9Cjl1sXqA9tg

# Parte 1

Implementacion 1
"""

import numpy as np
import time

class DiseñoPCB:

  def __init__(self,filas,columnas):

    # Se definen las dimensiones de la tabla
    self.filas = filas
    self.columnas = columnas
    #Almacenamos los caminos que se almacenan
    self.caminos_almacenados = []

# Del enunciado se pide 2 manerar de resolver el problema
# primero se realizara mediante recursividad.

  # Simulamos el comportamiento de una tabla como si fuera una matriz, luego
  # para poder movernos por la matriz, necesitamos los indices i,j.

  # i -> movimiento horizontal (representa las filas)
  # j -> movimiento vertical (representa las columnas)

  def Metodo_Recursivo(self,i,j,camino_actual):

    camino_actual.append((i,j))

    # Se verifica que llegamos a la esquiza inferior derecha (PUNTO B)
    if i==self.filas-1 and j==self.columnas-1:

      ruta=tuple(camino_actual)
      if ruta not in self.caminos_almacenados:
        self.caminos_almacenados.append(ruta)

      else: # evitamos duplicar los caminos y buscamos otro camino
        camino_actual.pop()
        return

 # Como debemos movernos en una tabla (matriz) es intuitivo pensar
 # que debemos representar todos lo movimientos posibles, tales como
 # (derecha,izquierda,abajo, arriba). Sin embargo, se tiene una restriccion
 # que no nos podemos devoler, y como se comienza en la esquina superior isquierda
 # el movmiento solo sera hacia la derecha y abajo.


    if j+1 < self.columnas: # Evalua si hay espacio para movernos hacia la derecha
        self.Metodo_Recursivo(i,j+1,camino_actual) # Nos movemos hacia la derecha

    if i+1 < self.filas: # Evalua si hay espacio para movernos hacia abajo
        self.Metodo_Recursivo(i+1,j,camino_actual) # Nos movemos hacia la abajo


  def visualizar_caminos(self):
    self.Metodo_Recursivo(0,0,[])
    return len(self.caminos_almacenados)


x = DiseñoPCB(3,3).visualizar_caminos()
print(f"Número de caminos únicos: {x}")


#logica del codigo
##############Explicar la parte facil#################


##############Explicar la parte deficil

# Supongamos que se tiene una matriz 3x3 y el siguiente camino [(0,0),(0,1),(0,2),(1,2),(2,2)]

# Al llegar al punto (2,2), aplicamos backtracking para regresar al camino anterior
# eliminando el último punto del camino con camino_actual.pop(), y llegamos a (1,2)

# En (1,2), se observa que:

# 1. La condición if i == self.filas - 1 and j == self.columnas - 1 no se cumple
#    , ya que no estamos en la esquina inferior derecha.

# 2. La condición if j + 1 < self.columnas tampoco se cumple, porque no podemos
#    movernos más a la derecha.

# 3. La condición if i + 1 < self.filas sí se cumple, lo que indica que podemos movernos
#   hacia abajo y avanzar al punto (2,2)


# Aquí surge un problema, si avanzamos hacia (2,2) nuevamente, se entraría en un ciclo
# ya que (2,2) ya ha sido visitado en el camino actual. Para evitar esto, se implemento una
# condición adicional. Si (2,2) ya está en camino_actual, se evita agregar el camino a
# self.caminos_almacenados. Después, camino_actual.pop() elimina el punto (1,2) para continuar
# explorando otras rutas posibles, y el caos siguiente seria revisar el (0,2)...asi sucesivamente

"""Implementacion real"""

import numpy as np

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo

    def Metodo_Recursivo(self, i, j, camino_actual):
        # Añadir la posición actual al camino
        camino_actual.append((i, j))

        # Si se ha llegado al destino (B)
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            # Almacena la ruta si no ha sido almacenada antes
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        # Explorar el camino hacia la derecha
        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        # Explorar el camino hacia abajo
        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        # Inicializa la primera posición como 1
        self.matriz_caminos[0][0] = 1

        # Utilizar programación dinámica para contar caminos posibles
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    def visualizar_caminos_recursivo(self):
        # Reinicia la lista de caminos antes de calcular
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Calcula caminos usando el método recursivo
resultado_recursivo = x.visualizar_caminos_recursivo()
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")

# Calcula caminos usando el método iterativo
resultado_iterativo = x.visualizar_caminos_iterativo()
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")

"""# Parte 2

Primero, puede crear un nuevo método por cada solución programada, que entregue el tiempo
de ejecución de dicha solución para un input determinado

Implementacion 1
"""

from time import perf_counter

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo

    def Metodo_Recursivo(self, i, j, camino_actual):
        camino_actual.append((i, j))
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        self.matriz_caminos[0][0] = 1
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    def visualizar_caminos_recursivo(self):
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

    def calcular_tiempo(self, metodo):

        inicio = perf_counter()
        resultado = metodo()
        fin = perf_counter()
        tiempo = fin - inicio
        return resultado, tiempo

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Medir el tiempo del método recursivo
resultado_recursivo, tiempo_recursivo = x.calcular_tiempo(x.visualizar_caminos_recursivo)
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")
print(f"Tiempo de ejecución (recursivo): {tiempo_recursivo:.6f} segundos")

# Medir el tiempo del método iterativo
resultado_iterativo, tiempo_iterativo = x.calcular_tiempo(x.visualizar_caminos_iterativo)
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")
print(f"Tiempo de ejecución (iterativo): {tiempo_iterativo:.6f} segundos")

"""# Parte 3

¿Qué pasaría si tuviese 6 soluciones distintas? ¿Tendría que programar 6 nuevas funciones o
métodos para extraer la información deseada? Sin dudas esto sería un problema, pues repetiría
muchas veces su código de forma innecesaria. Para evitar este escenario, puede aprovechar que
las funciones en Python aceptan como argumento no sólo tipos básicos de datos, sino que también (entre otras cosas) aceptan funciones.

Como resultado, se obtiene lo mismo que entrega la función func, pero además se ha extendido
su funcionalidad para hacer algo más. Sabiendo lo anterior, ahora puede programar un único
método que recibe una función, y puede calcular el tiempo de ejecución de dicha función
"""

import numpy as np
from time import perf_counter

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo

    def Metodo_Recursivo(self, i, j, camino_actual):
        # Añadir la posición actual al camino
        camino_actual.append((i, j))

        # Si se ha llegado al destino (B)
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            # Almacena la ruta si no ha sido almacenada antes
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        # Explorar el camino hacia la derecha
        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        # Explorar el camino hacia abajo
        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        # Inicializa la primera posición como 1
        self.matriz_caminos[0][0] = 1

        # Utilizar programación dinámica para contar caminos posibles
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    def visualizar_caminos_recursivo(self):
        # Reinicia la lista de caminos antes de calcular
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

    def calcular_tiempo_funcion(self, funcion):

        inicio = perf_counter()
        resultado = funcion()
        fin = perf_counter()
        tiempo = fin - inicio
        return resultado, tiempo

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Medir el tiempo del método recursivo
resultado_recursivo, tiempo_recursivo = x.calcular_tiempo_funcion(x.visualizar_caminos_recursivo)
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")
print(f"Tiempo de ejecución (recursivo): {tiempo_recursivo:.6f} segundos")

# Medir el tiempo del método iterativo
resultado_iterativo, tiempo_iterativo = x.calcular_tiempo_funcion(x.visualizar_caminos_iterativo)
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")
print(f"Tiempo de ejecución (iterativo): {tiempo_iterativo:.6f} segundos")

"""#Parte 4

Lo anterior es útil en varios casos, pero tiene el siguiente inconveniente: suponga que tiene un
proyecto de cientos de archivos, y en muchos de estos archivos tiene decenas de llamados a la
función func. Usted se vería en la obligación de cambiar todas esas llamadas de func(a, b)
por funcion_que_recibe_otra_funcion(func, a, b), lo que empeora mucho la legibilidad
de su código, se le podría olvidar cambiar alguno, y podría tener otros problemas que tienen
relación con la calidad de su código.

Para lidiar con estos problemas puede plantear la siguiente solución: usted tiene una función a la
que le desea agregar funcionalidad. En lugar de crear una nueva función que entregue el mismo
output, usted puede crear una función que renueve a func dotándola de nuevo funcionamiento.
Para ello, en vez de retornar el mismo valor de func, puede retornar una nueva versión de func
con el comportamiento extra que usted quiere entregarle.

Implementacion 1
"""

from time import perf_counter
import numpy as np

def medir_tiempo(funcion):
    def nueva_funcion(self):
        inicio = perf_counter()
        resultado = funcion(self)  # Solo pasamos "self", ya que no se usan otros parámetros
        fin = perf_counter()
        tiempo = fin - inicio
        print(f"Tiempo de ejecución: {tiempo:.6f} segundos")
        return resultado
    return nueva_funcion

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo

    def Metodo_Recursivo(self, i, j, camino_actual):
        camino_actual.append((i, j))
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        self.matriz_caminos[0][0] = 1
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    @medir_tiempo
    def visualizar_caminos_recursivo(self):
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    @medir_tiempo
    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Medir el tiempo del método recursivo usando el decorador
resultado_recursivo = x.visualizar_caminos_recursivo()
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")

# Medir el tiempo del método iterativo usando el decorador
resultado_iterativo = x.visualizar_caminos_iterativo()
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")

"""implementacion 2

#Parte 5

Programe un decorador que permita almacenar de alguna forma el tiempo de ejecución de una
función, y utilícelo para decorar un nuevo método en su clase. Este nuevo método debe ser capaz
de cambiar la forma en que calcula la respuesta entre las distintas soluciones que programó en
un principio.
"""

import time
import numpy as np

# Decorador para medir y almacenar el tiempo de ejecución
def medir_y_almacenar_tiempo(funcion):
    def nueva_funcion(self):
        if not hasattr(self, '_tiempos'):
            self._tiempos = []
        inicio = time.time()
        resultado = funcion(self)
        fin = time.time()
        tiempo = fin - inicio
        self._tiempos.append(tiempo)
        print(f"Tiempo de ejecución: {tiempo:.6f} segundos")
        return resultado
    return nueva_funcion

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo
        self._tiempos = []  # Almacena tiempos de ejecución

    def Metodo_Recursivo(self, i, j, camino_actual):
        camino_actual.append((i, j))
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        self.matriz_caminos[0][0] = 1
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    @medir_y_almacenar_tiempo
    def visualizar_caminos_recursivo(self):
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    @medir_y_almacenar_tiempo
    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

    # Nueva función para obtener tiempos
    def obtener_tiempos(self):
        return self._tiempos

    def calcular_caminos(self, metodo='recursivo'):
        if metodo == 'recursivo':
            return self.visualizar_caminos_recursivo()
        elif metodo == 'iterativo':
            return self.visualizar_caminos_iterativo()
        else:
            raise ValueError("Método no reconocido. Usa 'recursivo' o 'iterativo'.")

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Calcular caminos usando el método recursivo
resultado_recursivo = x.calcular_caminos(metodo='recursivo')
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")
print(f"Tiempos de ejecución del método recursivo: {x.obtener_tiempos()}")

# Calcular caminos usando el método iterativo
resultado_iterativo = x.calcular_caminos(metodo='iterativo')
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")
print(f"Tiempos de ejecución del método iterativo: {x.obtener_tiempos()}")

import time
import numpy as np

# Decorador para medir y almacenar el tiempo de ejecución
def medir_y_almacenar_tiempo(tipo):
    def decorador(funcion):
        def nueva_funcion(self):
            inicio = time.time()
            resultado = funcion(self)
            fin = time.time()
            tiempo = fin - inicio
            if tipo == 'recursivo':
                self._tiempo_recursivo = tiempo  # Almacena solo el último tiempo de ejecución del recursivo
            elif tipo == 'iterativo':
                self._tiempo_iterativo = tiempo  # Almacena solo el último tiempo de ejecución del iterativo
            return resultado
        return nueva_funcion
    return decorador

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)  # Para el método iterativo
        self._tiempo_recursivo = 0  # Almacena el último tiempo del método recursivo
        self._tiempo_iterativo = 0  # Almacena el último tiempo del método iterativo

    def Metodo_Recursivo(self, i, j, camino_actual):
        camino_actual.append((i, j))
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()  # Elimina la última posición antes de regresar
            return

        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()  # Quita la última posición antes de regresar en cada rama

    def Metodo_Iterativo(self):
        self.matriz_caminos[0][0] = 1
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    @medir_y_almacenar_tiempo('recursivo')
    def visualizar_caminos_recursivo(self):
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    @medir_y_almacenar_tiempo('iterativo')
    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

    # Función para obtener el último tiempo de ejecución específico para cada método
    def obtener_tiempo(self, metodo='recursivo'):
        if metodo == 'recursivo':
            return f"{self._tiempo_recursivo:.6f} segundos"
        elif metodo == 'iterativo':
            return f"{self._tiempo_iterativo:.6f} segundos"

    def calcular_caminos(self, metodo='recursivo'):
        if metodo == 'recursivo':
            return self.visualizar_caminos_recursivo()
        elif metodo == 'iterativo':
            return self.visualizar_caminos_iterativo()
        else:
            raise ValueError("Método no reconocido. Usa 'recursivo' o 'iterativo'.")

# Ejemplo de uso
x = DiseñoPCB(3, 3)

# Calcular caminos usando el método recursivo
resultado_recursivo = x.calcular_caminos(metodo='recursivo')
print(f"Recursivo - Número de caminos posibles: {resultado_recursivo}")
print(f"Tiempo de ejecución del método recursivo: {x.obtener_tiempo(metodo='recursivo')}")

# Calcular caminos usando el método iterativo
resultado_iterativo = x.calcular_caminos(metodo='iterativo')
print(f"Iterativo - Número de caminos posibles: {resultado_iterativo}")
print(f"Tiempo de ejecución del método iterativo: {x.obtener_tiempo(metodo='iterativo')}")

"""# Parte Final"""

import time
import numpy as np
import matplotlib.pyplot as plt

# Decorador para medir y almacenar el tiempo de ejecución
def medir_y_almacenar_tiempo(tipo):
    def decorador(funcion):
        def nueva_funcion(self):
            inicio = time.time()
            resultado = funcion(self)
            fin = time.time()
            tiempo = fin - inicio
            if tipo == 'recursivo':
                self._tiempo_recursivo = tiempo
            elif tipo == 'iterativo':
                self._tiempo_iterativo = tiempo
            return resultado
        return nueva_funcion
    return decorador

class DiseñoPCB:
    def __init__(self, filas, columnas):
        self.filas = filas
        self.columnas = columnas
        self.caminos_almacenados = []  # Para el método recursivo
        self.matriz_caminos = np.zeros((filas, columnas), dtype=int)
        self._tiempo_recursivo = 0
        self._tiempo_iterativo = 0

    def Metodo_Recursivo(self, i, j, camino_actual):
        camino_actual.append((i, j))
        if i == self.filas - 1 and j == self.columnas - 1:
            ruta = tuple(camino_actual)
            if ruta not in self.caminos_almacenados:
                self.caminos_almacenados.append(ruta)
            camino_actual.pop()
            return

        if j + 1 < self.columnas:
            self.Metodo_Recursivo(i, j + 1, camino_actual)

        if i + 1 < self.filas:
            self.Metodo_Recursivo(i + 1, j, camino_actual)

        camino_actual.pop()

    def Metodo_Iterativo(self):
        self.matriz_caminos[0][0] = 1
        for i in range(self.filas):
            for j in range(self.columnas):
                if i > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i - 1][j]
                if j > 0:
                    self.matriz_caminos[i][j] += self.matriz_caminos[i][j - 1]

    @medir_y_almacenar_tiempo('recursivo')
    def visualizar_caminos_recursivo(self):
        self.caminos_almacenados.clear()
        self.Metodo_Recursivo(0, 0, [])
        return len(self.caminos_almacenados)

    @medir_y_almacenar_tiempo('iterativo')
    def visualizar_caminos_iterativo(self):
        self.Metodo_Iterativo()
        return self.matriz_caminos[self.filas - 1][self.columnas - 1]

    def calcular_caminos(self, metodo='recursivo'):
        if metodo == 'recursivo':
            return self.visualizar_caminos_recursivo()
        elif metodo == 'iterativo':
            return self.visualizar_caminos_iterativo()
        else:
            raise ValueError("Método no reconocido. Usa 'recursivo' o 'iterativo'.")


############################## GRAFICO #########################################
n_matrices = list(range(2, 11))
tiempos_recursivo = []
tiempos_iterativo = []

for n in n_matrices:
    x = DiseñoPCB(n, n)

    x.calcular_caminos(metodo='recursivo')
    tiempos_recursivo.append(x._tiempo_recursivo)

    x.calcular_caminos(metodo='iterativo')
    tiempos_iterativo.append(x._tiempo_iterativo)

plt.figure(figsize=(10, 6))
plt.plot(n_matrices, tiempos_recursivo, marker='o', label='Recursivo', color='blue')
plt.plot(n_matrices, tiempos_iterativo, marker='o', label='Iterativo', color='green')
plt.xticks(n_matrices, [f"{n}x{n}" for n in n_matrices])
plt.xlabel('Tamaño de la grilla (n x n)')
plt.ylabel('Tiempo de ejecución (segundos)')
plt.title('Comparación de tiempos de ejecución entre métodos Recursivo e Iterativo')
plt.legend()
plt.grid(True)
plt.show()